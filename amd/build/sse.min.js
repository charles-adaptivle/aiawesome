define("local_aiawesome/sse",["exports"],(function(_exports){Object.defineProperty(_exports,"__esModule",{value:!0}),_exports.SSEClient=void 0,_exports.createSSEClient=createSSEClient,_exports.streamAIResponse=function(url,data){let callbacks=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const client=createSSEClient(url,{maxRetries:2,retryDelay:1e3,timeout:12e4});return client.addEventListener("open",(event=>{callbacks.onOpen&&callbacks.onOpen(event.detail)})),client.addEventListener("message",(event=>{const{data:messageData}=event.detail;callbacks.onMessage&&callbacks.onMessage(messageData),messageData&&"object"==typeof messageData&&(messageData.text&&callbacks.onToken&&callbacks.onToken(messageData.text,messageData),messageData.references&&callbacks.onReferences&&callbacks.onReferences(messageData.references),messageData.code&&callbacks.onError&&callbacks.onError(messageData))})),client.addEventListener("error",(event=>{const{error:error,retry:retry}=event.detail;callbacks.onError&&callbacks.onError({code:"NETWORK_ERROR",message:error.message,canRetry:retry})})),client.addEventListener("retrying",(event=>{callbacks.onRetry&&callbacks.onRetry(event.detail)})),client.addEventListener("close",(event=>{callbacks.onClose&&callbacks.onClose(event.detail)})),client.connect(data),client};
/**
   * Server-Sent Events client for AI Awesome plugin.
   *
   * @module     local_aiawesome/sse
   * @copyright  2025 Charles Horton <charles@adaptivle.co.uk>
   * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
   */
class SSEClient extends EventTarget{constructor(url){let options=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};super(),this.url=url,this.options={maxRetries:2,retryDelay:1e3,timeout:12e4,...options},this.eventSource=null,this.abortController=null,this.retryCount=0,this.isConnected=!1,this.lastEventId=null}async connect(){let data=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};this.abortController=new AbortController;try{const response=await fetch(this.url,{method:"POST",headers:{"Content-Type":"application/json",Accept:"text/event-stream"},body:JSON.stringify({...data,sesskey:M.cfg.sesskey}),signal:this.abortController.signal});if(!response.ok)throw new Error(`HTTP ${response.status}: ${response.statusText}`);const contentType=response.headers.get("content-type");if(!contentType||!contentType.includes("text/event-stream")){const errorText=await response.text();throw new Error(`Expected SSE response, got: ${contentType}. Response: ${errorText}`)}await this.processStream(response)}catch(error){if("AbortError"===error.name)return void this.emit("close",{reason:"aborted"});this.emit("error",{error:error,retry:this.shouldRetry()}),this.shouldRetry()&&await this.scheduleRetry(data)}}async processStream(response){const reader=response.body.getReader(),decoder=new TextDecoder;let buffer="";this.isConnected=!0,this.emit("open",{timestamp:Date.now()});try{for(;;){const{value:value,done:done}=await reader.read();if(done)break;if(this.abortController.signal.aborted)break;for(buffer+=decoder.decode(value,{stream:!0});buffer.includes("\n");){const lineEnd=buffer.indexOf("\n"),line=buffer.slice(0,lineEnd);buffer=buffer.slice(lineEnd+1),this.processLine(line.trim())}}}finally{reader.releaseLock(),this.isConnected=!1}this.emit("close",{reason:"completed"})}processLine(line){if(""!==line)if(line.startsWith("data: ")){const data=line.slice(6);try{const parsedData=JSON.parse(data);this.emit("message",{data:parsedData,timestamp:Date.now()})}catch(error){this.emit("message",{data:data,timestamp:Date.now()})}}else if(line.startsWith("event: ")){const eventType=line.slice(7);this.currentEventType=eventType}else if(line.startsWith("id: "))this.lastEventId=line.slice(4);else if(line.startsWith("retry: ")){const retryTime=parseInt(line.slice(7),10);isNaN(retryTime)||(this.options.retryDelay=retryTime)}}disconnect(){this.abortController&&this.abortController.abort(),this.eventSource&&(this.eventSource.close(),this.eventSource=null),this.isConnected=!1,this.retryCount=0}shouldRetry(){return this.retryCount<this.options.maxRetries}async scheduleRetry(data){this.retryCount++;const delay=this.options.retryDelay*Math.pow(2,this.retryCount-1);this.emit("retrying",{attempt:this.retryCount,maxRetries:this.options.maxRetries,delay:delay}),await new Promise((resolve=>setTimeout(resolve,delay))),this.abortController.signal.aborted||await this.connect(data)}emit(type){let detail=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};this.dispatchEvent(new CustomEvent(type,{detail:detail}))}get connected(){return this.isConnected}get stats(){return{connected:this.isConnected,retryCount:this.retryCount,maxRetries:this.options.maxRetries,lastEventId:this.lastEventId}}}function createSSEClient(url){let options=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return new SSEClient(url,options)}_exports.SSEClient=SSEClient}));

//# sourceMappingURL=sse.min.js.map