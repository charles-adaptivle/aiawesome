{"version":3,"file":"sse.min.js","sources":["../src/sse.js"],"sourcesContent":["/**\n * Server-Sent Events client for AI Awesome plugin.\n *\n * @module     local_aiawesome/sse\n * @copyright  2025 Charles Horton <charles@adaptivle.co.uk>\n * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n */\n\n/**\n * SSE client class with retry logic and error handling.\n */\nexport class SSEClient extends EventTarget {\n    constructor(url, options = {}) {\n        super();\n        this.url = url;\n        this.options = {\n            maxRetries: 2,\n            retryDelay: 1000,\n            timeout: 120000,\n            ...options\n        };\n        \n        this.eventSource = null;\n        this.abortController = null;\n        this.retryCount = 0;\n        this.isConnected = false;\n        this.lastEventId = null;\n    }\n\n    /**\n     * Connect to the SSE endpoint.\n     * \n     * @param {Object} data - Data to send in POST request\n     * @returns {Promise} Connection promise\n     */\n    async connect(data = {}) {\n        this.abortController = new AbortController();\n        \n        try {\n            // For Moodle, we need to POST first to authenticate and get the stream.\n            // The stream endpoint will handle SSE after authentication.\n            const response = await fetch(this.url, {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json',\n                    'Accept': 'text/event-stream',\n                },\n                body: JSON.stringify({\n                    ...data,\n                    sesskey: M.cfg.sesskey, // Moodle CSRF protection\n                }),\n                signal: this.abortController.signal,\n            });\n\n            if (!response.ok) {\n                throw new Error(`HTTP ${response.status}: ${response.statusText}`);\n            }\n\n            // Check if response is actually SSE\n            const contentType = response.headers.get('content-type');\n            if (!contentType || !contentType.includes('text/event-stream')) {\n                const errorText = await response.text();\n                throw new Error(`Expected SSE response, got: ${contentType}. Response: ${errorText}`);\n            }\n\n            // Process the streaming response\n            await this.processStream(response);\n            \n        } catch (error) {\n            if (error.name === 'AbortError') {\n                this.emit('close', { reason: 'aborted' });\n                return;\n            }\n\n            this.emit('error', { error, retry: this.shouldRetry() });\n\n            if (this.shouldRetry()) {\n                await this.scheduleRetry(data);\n            }\n        }\n    }\n\n    /**\n     * Process the streaming response.\n     * \n     * @param {Response} response - Fetch response object\n     */\n    async processStream(response) {\n        const reader = response.body.getReader();\n        const decoder = new TextDecoder();\n        let buffer = '';\n\n        this.isConnected = true;\n        this.emit('open', { timestamp: Date.now() });\n\n        try {\n            while (true) {\n                const { value, done } = await reader.read();\n                \n                if (done) {\n                    break;\n                }\n\n                if (this.abortController.signal.aborted) {\n                    break;\n                }\n\n                buffer += decoder.decode(value, { stream: true });\n                \n                // Process complete lines\n                while (buffer.includes('\\n')) {\n                    const lineEnd = buffer.indexOf('\\n');\n                    const line = buffer.slice(0, lineEnd);\n                    buffer = buffer.slice(lineEnd + 1);\n                    \n                    this.processLine(line.trim());\n                }\n            }\n        } finally {\n            reader.releaseLock();\n            this.isConnected = false;\n        }\n\n        this.emit('close', { reason: 'completed' });\n    }\n\n    /**\n     * Process a single SSE line.\n     * \n     * @param {string} line - SSE line to process\n     */\n    processLine(line) {\n        if (line === '') {\n            return; // Empty line, ignore\n        }\n\n        if (line.startsWith('data: ')) {\n            const data = line.slice(6);\n            try {\n                const parsedData = JSON.parse(data);\n                this.emit('message', { data: parsedData, timestamp: Date.now() });\n            } catch (error) {\n                // Non-JSON data, emit as text\n                this.emit('message', { data, timestamp: Date.now() });\n            }\n        } else if (line.startsWith('event: ')) {\n            const eventType = line.slice(7);\n            this.currentEventType = eventType;\n        } else if (line.startsWith('id: ')) {\n            this.lastEventId = line.slice(4);\n        } else if (line.startsWith('retry: ')) {\n            const retryTime = parseInt(line.slice(7), 10);\n            if (!isNaN(retryTime)) {\n                this.options.retryDelay = retryTime;\n            }\n        }\n    }\n\n    /**\n     * Disconnect from the stream.\n     */\n    disconnect() {\n        if (this.abortController) {\n            this.abortController.abort();\n        }\n        \n        if (this.eventSource) {\n            this.eventSource.close();\n            this.eventSource = null;\n        }\n        \n        this.isConnected = false;\n        this.retryCount = 0;\n    }\n\n    /**\n     * Check if we should retry the connection.\n     * \n     * @returns {boolean} Whether to retry\n     */\n    shouldRetry() {\n        return this.retryCount < this.options.maxRetries;\n    }\n\n    /**\n     * Schedule a retry attempt.\n     * \n     * @param {Object} data - Original connection data\n     */\n    async scheduleRetry(data) {\n        this.retryCount++;\n        \n        const delay = this.options.retryDelay * Math.pow(2, this.retryCount - 1); // Exponential backoff\n        \n        this.emit('retrying', { \n            attempt: this.retryCount, \n            maxRetries: this.options.maxRetries,\n            delay \n        });\n\n        await new Promise(resolve => setTimeout(resolve, delay));\n        \n        if (!this.abortController.signal.aborted) {\n            await this.connect(data);\n        }\n    }\n\n    /**\n     * Emit a custom event.\n     * \n     * @param {string} type - Event type\n     * @param {Object} detail - Event detail\n     */\n    emit(type, detail = {}) {\n        this.dispatchEvent(new CustomEvent(type, { detail }));\n    }\n\n    /**\n     * Check if currently connected.\n     * \n     * @returns {boolean} Connection status\n     */\n    get connected() {\n        return this.isConnected;\n    }\n\n    /**\n     * Get connection statistics.\n     * \n     * @returns {Object} Connection stats\n     */\n    get stats() {\n        return {\n            connected: this.isConnected,\n            retryCount: this.retryCount,\n            maxRetries: this.options.maxRetries,\n            lastEventId: this.lastEventId,\n        };\n    }\n}\n\n/**\n * Create an SSE client instance.\n * \n * @param {string} url - SSE endpoint URL\n * @param {Object} options - Client options\n * @returns {SSEClient} SSE client instance\n */\nexport function createSSEClient(url, options = {}) {\n    return new SSEClient(url, options);\n}\n\n/**\n * Utility function to handle common SSE patterns for AI streaming.\n * \n * @param {string} url - SSE endpoint URL\n * @param {Object} data - Data to send\n * @param {Object} callbacks - Event callbacks\n * @returns {SSEClient} SSE client instance\n */\nexport function streamAIResponse(url, data, callbacks = {}) {\n    const client = createSSEClient(url, {\n        maxRetries: 2,\n        retryDelay: 1000,\n        timeout: 120000,\n    });\n\n    // Set up event listeners\n    client.addEventListener('open', (event) => {\n        if (callbacks.onOpen) {\n            callbacks.onOpen(event.detail);\n        }\n    });\n\n    client.addEventListener('message', (event) => {\n        const { data: messageData } = event.detail;\n        \n        if (callbacks.onMessage) {\n            callbacks.onMessage(messageData);\n        }\n        \n        // Handle specific AI event types\n        if (messageData && typeof messageData === 'object') {\n            if (messageData.text && callbacks.onToken) {\n                callbacks.onToken(messageData.text, messageData);\n            }\n            \n            if (messageData.references && callbacks.onReferences) {\n                callbacks.onReferences(messageData.references);\n            }\n            \n            if (messageData.code && callbacks.onError) {\n                callbacks.onError(messageData);\n            }\n        }\n    });\n\n    client.addEventListener('error', (event) => {\n        const { error, retry } = event.detail;\n        \n        if (callbacks.onError) {\n            callbacks.onError({ \n                code: 'NETWORK_ERROR', \n                message: error.message, \n                canRetry: retry \n            });\n        }\n    });\n\n    client.addEventListener('retrying', (event) => {\n        if (callbacks.onRetry) {\n            callbacks.onRetry(event.detail);\n        }\n    });\n\n    client.addEventListener('close', (event) => {\n        if (callbacks.onClose) {\n            callbacks.onClose(event.detail);\n        }\n    });\n\n    // Start the connection\n    client.connect(data);\n\n    return client;\n}"],"names":["url","data","callbacks","client","createSSEClient","maxRetries","retryDelay","timeout","addEventListener","event","onOpen","detail","messageData","onMessage","text","onToken","references","onReferences","code","onError","error","retry","message","canRetry","onRetry","onClose","connect","SSEClient","EventTarget","constructor","options","eventSource","abortController","retryCount","isConnected","lastEventId","AbortController","response","fetch","this","method","headers","body","JSON","stringify","sesskey","M","cfg","signal","ok","Error","status","statusText","contentType","get","includes","errorText","processStream","name","emit","reason","shouldRetry","scheduleRetry","reader","getReader","decoder","TextDecoder","buffer","timestamp","Date","now","value","done","read","aborted","decode","stream","lineEnd","indexOf","line","slice","processLine","trim","releaseLock","startsWith","parsedData","parse","eventType","currentEventType","retryTime","parseInt","isNaN","disconnect","abort","close","delay","Math","pow","attempt","Promise","resolve","setTimeout","type","dispatchEvent","CustomEvent","connected","stats"],"mappings":"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"}